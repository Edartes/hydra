#! /usr/bin/env perl

use strict;
use utf8;
use Hydra::Schema;
use Hydra::Plugin;
use Hydra::Helper::Nix;
use Hydra::Helper::AddBuilds;
use Hydra::Helper::Email;
use Hydra::Model::DB;
use Digest::SHA qw(sha256_hex);
use Config::General;
use Data::Dump qw(dump);
use Try::Tiny;
use Net::Statsd;
use Time::HiRes qw(clock_gettime CLOCK_REALTIME);
use JSON;
use File::Slurp;

STDOUT->autoflush();
STDERR->autoflush(1);
binmode STDERR, ":encoding(utf8)";

my $db = Hydra::Model::DB->new();
my $config = getHydraConfig();

my $plugins = [Hydra::Plugin->instantiate(db => $db, config => $config)];

my $dryRun = defined $ENV{'HYDRA_DRY_RUN'};


sub fetchInputs {
    my ($project, $jobset, $inputInfo) = @_;
    foreach my $input ($jobset->jobset_inputs->all) {
        foreach my $alt ($input->jobset_input_alts->all) {
            push @{$$inputInfo{$input->name}}, $_
                foreach fetchInput($plugins, $db, $project, $jobset, $input->name, $input->type, $alt->value, $input->email_responsible);
        }
    }
}


sub setJobsetError {
    my ($jobset, $errorMsg) = @_;
    my $prevError = $jobset->error_msg;

    eval {
        txn_do($db, sub {
            $jobset->update({ error_msg => $errorMsg, error_time => time, fetch_error_msg => undef });
        });
    };
    if (defined $errorMsg && $errorMsg ne ($prevError // "") || $ENV{'HYDRA_MAIL_TEST'}) {
        sendJobsetErrorNotification($jobset, $errorMsg);
    }
}


sub sendJobsetErrorNotification() {
    my ($jobset, $errorMsg) = @_;

    chomp $errorMsg;

    return if $jobset->project->owner->email_on_error == 0;
    return if $errorMsg eq "";

    my $projectName = $jobset->project->name;
    my $jobsetName = $jobset->name;
    my $body = "Hi,\n"
        . "\n"
        . "This is to let you know that evaluation of the Hydra jobset ‘$projectName:$jobsetName’\n"
        . "resulted in the following error:\n"
        . "\n"
        . "$errorMsg"
        . "\n"
        . "Regards,\n\nThe Hydra build daemon.\n";

    try {
        sendEmail(
            $config,
            $jobset->project->owner->email_address,
            "Hydra $projectName:$jobsetName evaluation error",
            $body,
            [ 'X-Hydra-Project' => $projectName
            , 'X-Hydra-Jobset'  => $jobsetName
            ]);
    } catch {
        warn "error sending email: $_\n";
    };
}


sub permute {
    my @list = @_;
    for (my $n = scalar @list - 1; $n > 0; $n--) {
        my $k = int(rand($n + 1)); # 0 <= $k <= $n
        @list[$n, $k] = @list[$k, $n];
    }
    return @list;
}


sub checkJobsetWrapped {
    my ($jobset) = @_;
    my $project = $jobset->project;
    my $jobsetsJobset = length($project->declfile) && $jobset->name eq ".jobsets";
    my $inputInfo = {};
    if ($jobsetsJobset) {
        my @declInputs = fetchInput($plugins, $db, $project, $jobset, "decl", $project->decltype, $project->declvalue, 0);
        my $declInput = @declInputs[0] or die "cannot find the input containing the declarative project specification\n";
        die "multiple alternatives for the input containing the declarative project specificaiton are not supported\n"
            if scalar @declInputs != 1;
        my $declFile = $declInput->{storePath} . "/" . $project->declfile;
        my $declText = read_file($declFile)
            or die "Couldn't read declarative specification file $declFile: $!\n";
        my $declSpec;
        eval {
            $declSpec = decode_json($declText);
        };
        die "Declarative specification file $declFile not valid JSON: $@\n" if $@;
        updateDeclarativeJobset($db, $project, ".jobsets", $declSpec);
        $jobset->discard_changes;
        $inputInfo->{"declInput"} = [ $declInput ];
    }
    my $exprType = $jobset->nix_expr_path =~ /.scm$/ ? "guile" : "nix";

    # Fetch all values for all inputs.
    my $checkoutStart = clock_gettime(CLOCK_REALTIME);
    eval {
        fetchInputs($project, $jobset, $inputInfo);
    };
    my $fetchError = $@;

    Net::Statsd::increment("hydra.evaluator.checkouts");
    my $checkoutStop = clock_gettime(CLOCK_REALTIME);
    Net::Statsd::timing("hydra.evaluator.checkout_time", int(($checkoutStop - $checkoutStart) * 1000));

    if ($fetchError) {
        Net::Statsd::increment("hydra.evaluator.failed_checkouts");
        print STDERR $fetchError;
        txn_do($db, sub {
            $jobset->update({ last_checked_time => time, fetch_error_msg => $fetchError }) if !$dryRun;
        });
        return;
    }

    # Hash the arguments to hydra-eval-jobs and check the
    # JobsetInputHashes to see if the previous evaluation had the same
    # inputs.  If so, bail out.
    my @args = ($jobset->nix_expr_input, $jobset->nix_expr_path, inputsToArgs($inputInfo, $exprType));
    my $argsHash = sha256_hex("@args");
    my $prevEval = getPrevJobsetEval($db, $jobset, 0);
    if (defined $prevEval && $prevEval->hash eq $argsHash && !$dryRun) {
        print STDERR "  jobset is unchanged, skipping\n";
        Net::Statsd::increment("hydra.evaluator.unchanged_checkouts");
        txn_do($db, sub {
            $jobset->update({ last_checked_time => time, fetch_error_msg => undef });
        });
        return;
    }

    # Evaluate the job expression.
    my $evalStart = clock_gettime(CLOCK_REALTIME);
    my ($jobs, $nixExprInput) = evalJobs($inputInfo, $exprType, $jobset->nix_expr_input, $jobset->nix_expr_path);
    my $evalStop = clock_gettime(CLOCK_REALTIME);

    if ($jobsetsJobset) {
        my @keys = keys %$jobs;
        die "The .jobsets jobset must only have a single job named 'jobsets'"
            unless (scalar @keys) == 1 && $keys[0] eq "jobsets";
    }
    Net::Statsd::timing("hydra.evaluator.eval_time", int(($evalStop - $evalStart) * 1000));

    if ($dryRun) {
        foreach my $name (keys %{$jobs}) {
            my $job = $jobs->{$name};
            if (defined $job->{drvPath}) {
                print STDERR "good job $name: $job->{drvPath}\n";
            } else {
                print STDERR "failed job $name: $job->{error}\n";
            }
        }
        return;
    }

    $jobs->{$_}->{jobName} = $_ for keys %{$jobs};

    my $jobOutPathMap = {};
    my $jobsetChanged = 0;
    my $dbStart = clock_gettime(CLOCK_REALTIME);

    txn_do($db, sub {

        my $prevEval = getPrevJobsetEval($db, $jobset, 1);

        # Clear the "current" flag on all builds.  Since we're in a
        # transaction this will only become visible after the new
        # current builds have been added.
        $jobset->builds->search({is_current => 1})->update({is_current => 0});

        # Schedule each successfully evaluated job.
        my %buildMap;
        foreach my $job (permute(values %{$jobs})) {
            next if defined $job->{error};
            #print STDERR "considering job " . $project->name, ":", $jobset->name, ":", $job->{jobName} . "\n";
            checkBuild($db, $jobset, $inputInfo, $nixExprInput, $job, \%buildMap, $prevEval, $jobOutPathMap, $plugins);
        }

        # Have any builds been added or removed since last time?
        $jobsetChanged =
            (scalar(grep { $_->{new} } values(%buildMap)) > 0)
            || (defined $prevEval && $prevEval->jobset_eval_members->count != scalar(keys %buildMap));

        my $ev = $jobset->jobset_evals->create(
            { hash => $argsHash
            , timestamp => time
            , checkout_time => abs(int($checkoutStop - $checkoutStart))
            , eval_time => abs(int($evalStop - $evalStart))
            , has_new_builds => $jobsetChanged ? 1 : 0
            , nr_builds => $jobsetChanged ? scalar(keys %buildMap) : undef
            });

        if ($jobsetChanged) {
            # Create JobsetEvalMembers mappings.
            while (my ($id, $x) = each %buildMap) {
                $ev->jobset_eval_members->create({ build => $id, is_new => $x->{new} });
            }

            # Create AggregateConstituents mappings.  Since there can
            # be jobs that alias each other, if there are multiple
            # builds for the same derivation, pick the one with the
            # shortest name.
            my %drvPathToId;
            while (my ($id, $x) = each %buildMap) {
                my $y = $drvPathToId{$x->{drvPath}};
                if (defined $y) {
                    next if length $x->{jobName} > length $y->{jobName};
                    next if length $x->{jobName} == length $y->{jobName} && $x->{jobName} ge $y->{jobName};
                }
                $drvPathToId{$x->{drvPath}} = $x;
            }

            foreach my $job (values %{$jobs}) {
                next unless $job->{constituents};
                my $x = $drvPathToId{$job->{drvPath}} or die;
                foreach my $drvPath (split / /, $job->{constituents}) {
                    my $constituent = $drvPathToId{$drvPath};
                    if (defined $constituent) {
                        $db->resultset('AggregateConstituents')->update_or_create({aggregate => $x->{id}, constituent => $constituent->{id}});
                    } else {
                        warn "aggregate job ‘$job->{jobName}’ has a constituent ‘$drvPath’ that doesn't correspond to a Hydra build\n";
                    }
                }
            }

            foreach my $name (keys %{$inputInfo}) {
                for (my $n = 0; $n < scalar(@{$inputInfo->{$name}}); $n++) {
                    my $input = $inputInfo->{$name}->[$n];
                    $ev->jobset_eval_inputs->create(
                        { name => $name
                        , alt_nr => $n
                        , type => $input->{type}
                        , uri => $input->{uri}
                        , revision => $input->{revision}
                        , value => $input->{value}
                        , dependency => $input->{id}
                        , path => $input->{storePath} || "" # !!! temporary hack
                        , sha256hash => $input->{sha256hash}
                        });
                }
            }

            print STDERR "  created new eval ", $ev->id, "\n";
            $ev->builds->update({is_current => 1});
        } else {
            print STDERR "  created cached eval ", $ev->id, "\n";
            $prevEval->builds->update({is_current => 1}) if defined $prevEval;
        }

        # If this is a one-shot jobset, disable it now.
        $jobset->update({ enabled => 0 }) if $jobset->enabled == 2;

        $jobset->update({ last_checked_time => time });
    });

    my $dbStop = clock_gettime(CLOCK_REALTIME);

    Net::Statsd::timing("hydra.evaluator.db_time", int(($dbStop - $dbStart) * 1000));
    Net::Statsd::increment("hydra.evaluator.evals");
    Net::Statsd::increment("hydra.evaluator.cached_evals") unless $jobsetChanged;

    # Store the error messages for jobs that failed to evaluate.
    my $msg = "";
    foreach my $job (values %{$jobs}) {
        next unless defined $job->{error};
        $msg .=
            ($job->{jobName} ne "" ? "in job ‘$job->{jobName}’" : "at top-level") .
            ":\n" . $job->{error} . "\n\n";
    }
    setJobsetError($jobset, $msg);
}


sub checkJobset {
    my ($jobset) = @_;

    print STDERR "considering jobset ", $jobset->project->name, ":", $jobset->name,
      $jobset->last_checked_time
          ? " (last checked " . (time() - $jobset->last_checked_time) . "s ago)\n"
          : " (never checked)\n";

    my $triggerTime = $jobset->trigger_time;

    my $startTime = clock_gettime(CLOCK_REALTIME);

    eval {
        checkJobsetWrapped($jobset);
    };
    my $checkError = $@;

    my $stopTime = clock_gettime(CLOCK_REALTIME);
    Net::Statsd::timing("hydra.evaluator.total_time", int(($stopTime - $startTime) * 1000));

    my $failed = 0;
    if ($checkError) {
        print STDERR $checkError;
        txn_do($db, sub {
            $jobset->update({last_checked_time => time});
            setJobsetError($jobset, $checkError);
        }) if !$dryRun;
        $failed = 1;
    }

    if (defined $triggerTime) {
        txn_do($db, sub {
            # Only clear the trigger time if the jobset hasn't been
            # triggered in the meantime.  In that case, we need to
            # evaluate again.
            my $new = $jobset->get_from_storage();
            $jobset->update({ trigger_time => undef })
                if $new->trigger_time == $triggerTime;
        }) if !$dryRun;
    }

    return $failed;
}


sub checkSomeJobset {
    # If any jobset has been triggered by a push, check it.
    my ($jobset) = $db->resultset('Jobsets')->search(
        { 'trigger_time' => { '!=', undef } },
        { join => 'project', order_by => [ 'trigger_time' ], rows => 1 });

    # Otherwise, check the jobset that hasn't been checked for the
    # longest time (but don't check more often than the jobset's
    # minimal check interval).
    ($jobset) = $db->resultset('Jobsets')->search(
        { 'project.enabled' => 1, 'me.enabled' => { '!=' => 0 },
        , 'check_interval' => { '!=', 0 }
        , -or => [ 'last_checked_time' => undef, 'last_checked_time' => { '<', \ (time() . " - me.check_interval") } ] },
        { join => 'project', order_by => [ 'last_checked_time nulls first' ], rows => 1 })
        unless defined $jobset;

    return 0 unless defined $jobset;

    return system($0, $jobset->project->name, $jobset->name) == 0;
}


if (scalar @ARGV == 2) {
    my $projectName = $ARGV[0];
    my $jobsetName = $ARGV[1];
    my $jobset = $db->resultset('Jobsets')->find($projectName, $jobsetName) or 
      die "$0: specified jobset \"$projectName:$jobsetName\" does not exist\n";
    exit checkJobset($jobset);
}


while (1) {
    eval {
        if (checkSomeJobset) {
            # Just so we don't go completely crazy if lastcheckedtime
            # isn't updated properly.
            sleep 1;
        } else {
            # print STDERR "sleeping...\n";
            sleep 30;
        }
    };
    if ($@) { print STDERR "$@"; }
}
